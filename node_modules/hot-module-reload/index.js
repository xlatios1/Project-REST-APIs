var fs = require('fs');
var path = require('path');
var Module = require('module');
var chokidar = require('chokidar');
var { DepGraph } = require('dependency-graph');
var EventEmitter = require('events');
var Debug = require('debug');


const debug = Debug('hot-reload');
const graph = new DepGraph();
const watcher = chokidar.watch(process.cwd(), { ignoreInitial:true });

const loaders = {};
function registerLoader(loader, path) {
  (loaders[path] || (loaders[path] = new Set())).add(loader);
}

function shouldWatch(path) {
  return path[0] === '/' && !path.match(/\/node_modules\//);
}


const __require = Module.prototype.require;
let moduleRequired = (path) => { };

Module.prototype.require = function(p) {
  const module = __require.call(this, p);
  const modulePath = Module._resolveFilename(p, this);
  if (shouldWatch(modulePath)) {
    graph.addNode(this.filename);
    graph.addNode(modulePath);
    graph.addDependency(this.filename, modulePath);
    moduleRequired(modulePath);
  }
  return module;
};

Module.prototype.hotReload = new EventEmitter();


module.exports = reload;

function reload(loader) {
  const oldModuleRequired = moduleRequired;
  try {
    const loadedPaths = new Set();
    moduleRequired = (path) => {
      registerLoader(loader, path);
      loadedPaths.add(path);
    };
    loader({ unload:unloadModule });
    loader.loadedPaths = loadedPaths;
  } finally {
    moduleRequired = oldModuleRequired;
  }
};


function unloadModule(path) {
  const paths = (graph.hasNode(path) ? graph.dependantsOf(path) : []).concat([path]);
  paths.forEach(path => {
    const mod = require.cache[path];
    if (mod) {
      delete require.cache[path]
      mod.hotReload.emit('unload', unloadModule);
    }
  });
  return paths;
}


function clearDependencies(paths) {
  const touchedLoaders = new Set();
  paths.forEach(path => {
    graph.removeNode(path);
    if (loaders[path]) {
      loaders[path].forEach((loader) => {
        touchedLoaders.add(loader);
      });
      delete loaders[path];
    }
  });
  return touchedLoaders;
}


watcher.on('all', (event, path) => {
  if (loaders[path]) {
    debug(path);
    const paths = unloadModule(path);
    const loaders = clearDependencies(paths);
    loaders.forEach((loader) => {
      const loadedPaths = loader.loadedPaths;
      try {
        reload(loader);
      } catch (e) {
        debug(e.stack || e);
        loadedPaths.forEach((path) => {
          registerLoader(loader, path);
        });
      }
    });
  }
});
